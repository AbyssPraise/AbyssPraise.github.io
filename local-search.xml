<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>职业生涯</title>
    <link href="/2024/04/25/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"/>
    <url>/2024/04/25/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="22-35"><a href="#22-35" class="headerlink" title="22-35"></a>22-35</h2><p>积累燃料阶段，注重积累，找到长板</p><h3 id="Transferable-Skills"><a href="#Transferable-Skills" class="headerlink" title="Transferable Skills"></a>Transferable Skills</h3><h4 id="解决问题能力"><a href="#解决问题能力" class="headerlink" title="解决问题能力"></a>解决问题能力</h4><p>解决问题的动机，从问题的根源思考</p><p>全局思维，思考每个环节，主动找到需要解决的问题并解决</p><h4 id="沟通能力"><a href="#沟通能力" class="headerlink" title="沟通能力"></a>沟通能力</h4><ol><li>最重要的是要有同理心，打开自己真正的内心</li><li>锻炼<strong>讲故事的能力</strong></li><li>逻辑性</li></ol><h2 id="35-50"><a href="#35-50" class="headerlink" title="35-50"></a>35-50</h2><p>聚焦长板，突出差异</p><h2 id="50-65"><a href="#50-65" class="headerlink" title="50-65"></a>50-65</h2><p>发挥影响力</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞、非阻塞与同步、异步本质区别是什么</title>
    <link href="/2024/04/18/%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2024/04/18/%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>是否阻塞，与执行流是否被暂停执行有关</strong></li><li><strong>异步无依赖</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin语法</title>
    <link href="/2024/04/18/Kotlin%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/04/18/Kotlin%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin实用扩展函数"><a href="#Kotlin实用扩展函数" class="headerlink" title="Kotlin实用扩展函数"></a>Kotlin实用扩展函数</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> nullableValue: String? = <span class="hljs-literal">null</span><br>nullableValue.withNotNull &#123; value -&gt;<br>    <span class="hljs-comment">// 只有在nullableValue不为空时才会执行此处的代码</span><br>&#125;<br><br><span class="hljs-keyword">val</span> flow = flowOf(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br><span class="hljs-keyword">val</span> liveData = flow.toLiveData()<br><br><span class="hljs-keyword">val</span> list: List&lt;<span class="hljs-built_in">Int</span>&gt; = emptyList()<br><span class="hljs-keyword">if</span> (list.notEmpty()) &#123;<br>    <span class="hljs-comment">// 只有在list不为空时才会执行此处的代码</span><br>&#125;<br><br><span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span> to <span class="hljs-string">&quot;value2&quot;</span>)<br><span class="hljs-keyword">val</span> value = map.getOrThrow(<span class="hljs-string">&quot;key3&quot;</span>)<br><br><span class="hljs-comment">//格式化数字和日期</span><br><span class="hljs-keyword">val</span> number = <span class="hljs-number">1000000</span><br><span class="hljs-keyword">val</span> formattedNumber = number.toFormattedString()<br><br><span class="hljs-keyword">val</span> drawable = ContextCompat.getDrawable(context, R.drawable.my_drawable)<br><span class="hljs-keyword">val</span> bitmap = drawable.toBitmap()<br><br><span class="hljs-keyword">val</span> filePath = <span class="hljs-string">&quot;/storage/emulated/0/Download/my_file.pdf&quot;</span><br><span class="hljs-keyword">val</span> fileUri = filePath.toUri()<br><br><span class="hljs-keyword">val</span> number = <span class="hljs-number">5</span><br><span class="hljs-keyword">val</span> formattedNumber = number.applyIf(number &gt; <span class="hljs-number">10</span>) &#123;<br>    toFormattedString()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">onClick</span><span class="hljs-params">(debounceDuration: <span class="hljs-type">Long</span> = <span class="hljs-number">300</span>L, action: (<span class="hljs-type">View</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    setOnClickListener(DebouncedOnClickListener(debounceDuration) &#123;<br>        action(it)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebouncedOnClickListener</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> debounceDuration: <span class="hljs-built_in">Long</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clickAction: (View) -&gt; <span class="hljs-built_in">Unit</span><br>) : View.OnClickListener &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastClickTime: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> now = SystemClock.elapsedRealtime()<br>        <span class="hljs-keyword">if</span> (now - lastClickTime &gt;= debounceDuration) &#123;<br>            lastClickTime = now<br>            clickAction(v)<br>        &#125;<br>    &#125;<br>&#125;<br>button.onClick(debounceDuration = <span class="hljs-number">500L</span>) &#123;<br>    <span class="hljs-comment">// 只有在距离上次点击已经过去500毫秒后才会执行此处的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么重写equals()时需要重写hashCode()?</title>
    <link href="/2024/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99hashCode/"/>
    <url>/2024/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E6%97%B6%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99hashCode/</url>
    
    <content type="html"><![CDATA[<p>equals()的API Note写道：</p><blockquote><p>通常有必要在重写equals()时重写hashCode，以维护hashCode的Contract</p></blockquote><h3 id="hashCode-的Contract"><a href="#hashCode-的Contract" class="headerlink" title="hashCode()的Contract"></a>hashCode()的Contract</h3><ul><li>当equals用的信息没有被修改的情况下,一个进程中，多次调用hashCode返回同一个值</li><li>如果根据equals判定两个对象相等，那么这两个对象的hashCode返回值相等</li><li>当两个对象不是 equals 的，它们的hashCode<strong>不是一定要不相等</strong>。但是，如果对于not equals 的对象，hashCode不相等<strong>或许</strong>能够提升hash table 的性能。</li></ul><p>重写equals必须重写hashCode是<strong>为了维护hashCode的第二条Contract</strong>：</p><p>如果根据equals判定两个对象相等，那么这两个对象的hashCode返回值相等。</p><p><em>假如不重写hashCode</em></p><p><em>如果原本not equal 的obj 经过重写queals 变成了 queal的</em></p><p><em>在重写queals之前它们的hashCode不相等。</em></p><p><em>那么此时，equals判定这两个对象相等，但是它们的hashCode不相等</em></p><p><em>因此有必要重写hashCode</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是预检请求</title>
    <link href="/2024/04/18/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/"/>
    <url>/2024/04/18/%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>CORS预检请求：浏览器在发起跨域请求时要先向服务器发起的 OPTIONS请求</p><p>HTTP请求有简单请求和预检请求，简单请求不会触发CORS预检</p><p><strong>什么是简单请求？</strong></p><p>同时满足：</p><ol><li><p>GET  POST  HEAD  三个方法之内</p></li><li><p>请求的 HTTP 标头只能是以下几种常见的标头：</p><p>Accept</p><p>Accept-Language</p><p>Content-Language</p><p>Last-Event-ID</p><p>Content-Type（仅限于 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）。</p><p>HTML 头部 header field 字段：DPR、Download、Save-Data、Viewport-Width、WIdth。</p></li><li><p>请求不能包含用户自定义的标头 且- 请求中没有使用 ReadableStream 对象</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2024/04/14/HTTPS/"/>
    <url>/2024/04/14/HTTPS/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP1-1-1997"><a href="#HTTP1-1-1997" class="headerlink" title="HTTP1.1(1997)"></a>HTTP1.1(1997)</h3><h4 id="基于TCP"><a href="#基于TCP" class="headerlink" title="基于TCP"></a>基于TCP</h4><p>TCP为了拥塞控制，慢启动</p><h4 id="浏览器控制一个域的TCP连接数"><a href="#浏览器控制一个域的TCP连接数" class="headerlink" title="浏览器控制一个域的TCP连接数"></a>浏览器控制一个域的TCP连接数</h4><h4 id="单个TCP连接只能one-by-one-地进行请求响应"><a href="#单个TCP连接只能one-by-one-地进行请求响应" class="headerlink" title="单个TCP连接只能one by one 地进行请求响应"></a>单个TCP连接只能one by one 地进行请求响应</h4><h5 id="队头阻塞（HTTP层面）"><a href="#队头阻塞（HTTP层面）" class="headerlink" title="队头阻塞（HTTP层面）"></a>队头阻塞（HTTP层面）</h5><p>前面的请求-响应阻塞的话，后面所有的请求-响应都会阻塞</p><h5 id="队头阻塞（TCP层面）"><a href="#队头阻塞（TCP层面）" class="headerlink" title="队头阻塞（TCP层面）"></a>队头阻塞（TCP层面）</h5><p>发送窗口、接收窗口按序处理数据包</p><h4 id="首部重复、未经压缩"><a href="#首部重复、未经压缩" class="headerlink" title="首部重复、未经压缩"></a>首部重复、未经压缩</h4><p>请求-响应中的首部往往存在大量重复首部</p><h3 id="HTTP2-2015"><a href="#HTTP2-2015" class="headerlink" title="HTTP2(2015)"></a>HTTP2(2015)</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>同一个TCP连接可以存在多个stream，报文在多个stream内同时传输。任一Stream的 TCPsegment丢失，会导致其他正在进行的Stream阻塞。(原因：TCP队头阻塞)</p><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HPACK算法</p><h4 id="报文变成二进制帧"><a href="#报文变成二进制帧" class="headerlink" title="报文变成二进制帧"></a>报文变成二进制帧</h4><h3 id="HTTP3-2019"><a href="#HTTP3-2019" class="headerlink" title="HTTP3(2019)"></a>HTTP3(2019)</h3><h4 id="TCP握手TLS握手整合"><a href="#TCP握手TLS握手整合" class="headerlink" title="TCP握手TLS握手整合"></a>TCP握手TLS握手整合</h4><p><img src="https://gitee.com/leepen713/typora/raw/master/pic/20240324145330.png" alt="20240324145330"></p><h4 id="QUIC层快不是因为基于UDP"><a href="#QUIC层快不是因为基于UDP" class="headerlink" title="QUIC层快不是因为基于UDP"></a>QUIC层快不是因为基于UDP</h4><p><img src="https://gitee.com/leepen713/typora/raw/master/pic/20240324150437.jpg" alt="20240324150437"></p><p>基于UDP是为了能够广泛部署</p><p>QUIC大部分内容是整合了TCP和TLS，并且<strong>解决了TCP队头阻塞问题</strong></p><p>QUIC数据包会加密QUIC帧内容</p><p>QUIC数据包会添加 ConnectionID 用来表示是否是同一个连接。应用场景：WIFI切换4G，IP地址变了，连接没变，所以不用重新握手。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
